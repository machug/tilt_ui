import{p}from"./Clf_rkwX.js";const e=p({tilts:new Map,connected:!1,ambient:null,heater:{state:null,entity_id:null,last_changed:null,available:!1,loading:!1}});let o=null,s=null;function u(){if(o?.readyState===WebSocket.OPEN)return;const n=`${window.location.protocol==="https:"?"wss:":"ws:"}//${window.location.host}/ws`;console.log("Connecting to WebSocket:",n),o=new WebSocket(n),o.onopen=()=>{console.log("WebSocket connected"),e.connected=!0,s&&(clearTimeout(s),s=null)},o.onmessage=i=>{try{const t=JSON.parse(i.data);if(t.type==="ambient"){e.ambient={temperature:t.temperature,humidity:t.humidity,timestamp:t.timestamp};return}if(t.type==="control_event"){t.action==="heat_on"?(e.heater.state="on",e.heater.last_changed=t.timestamp):t.action==="heat_off"&&(e.heater.state="off",e.heater.last_changed=t.timestamp);return}const r=t;e.tilts.set(r.id,r),e.tilts=new Map(e.tilts)}catch(t){console.error("Failed to parse WebSocket message:",t)}},o.onclose=()=>{console.log("WebSocket disconnected"),e.connected=!1,o=null,s=setTimeout(u,3e3)},o.onerror=i=>{console.error("WebSocket error:",i),o?.close()}}function f(){s&&(clearTimeout(s),s=null),o?.close(),o=null}let l=null;async function c(){try{e.heater.loading=!0;const a=await fetch("/api/control/heater");if(a.ok){const n=await a.json();e.heater.state=n.state,e.heater.entity_id=n.entity_id,e.heater.last_changed=n.last_changed,e.heater.available=n.available}}catch(a){console.error("Failed to fetch heater state:",a)}finally{e.heater.loading=!1}}function h(a=3e4){c(),l&&clearInterval(l),l=setInterval(c,a)}function g(){l&&(clearInterval(l),l=null)}async function m(a,n){try{if((await fetch(`/api/tilts/${a}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify({beer_name:n})})).ok){const t=e.tilts.get(a);return t&&(t.beer_name=n,e.tilts=new Map(e.tilts)),!0}}catch(i){console.error("Failed to update beer name:",i)}return!1}async function y(a,n){try{if((await fetch(`/api/tilts/${a}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify({original_gravity:n})})).ok){const t=e.tilts.get(a);return t&&(t.original_gravity=n,e.tilts=new Map(e.tilts)),!0}}catch(i){console.error("Failed to update original gravity:",i)}return!1}export{g as a,y as b,u as c,f as d,h as s,e as t,m as u};
